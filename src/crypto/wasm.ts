/**
 * Copyright (C) 2025 efchat <tj@efchat.net>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

import * as MatrixCrypto from '@matrix-org/matrix-sdk-crypto-wasm';
import type {
  ClaimedOneTimeKey,
  EncryptedMessage,
  IdentityKeys,
  KeyPair,
  OneTimeKey,
  PlaintextMessage,
  PreKeyBundle,
  Session,
} from './types.js';
import { MessageType } from './types.js';

let isInitialized = false;
let olmMachine: MatrixCrypto.OlmMachine | null = null;
let currentUserId: string | null = null;
let currentDeviceId: string | null = null;

export async function initializeWasm(): Promise<void> {
  if (isInitialized) {
    return;
  }

  try {
    await MatrixCrypto.initAsync();
    isInitialized = true;
  } catch (error) {
    console.error('Failed to initialize Matrix WASM:', error);
    throw error;
  }
}

export async function createOlmMachine(userId: string, deviceId: string): Promise<void> {
  if (!isInitialized) {
    await initializeWasm();
  }

  try {
    olmMachine = await MatrixCrypto.OlmMachine.initialize(
      new MatrixCrypto.UserId(userId),
      new MatrixCrypto.DeviceId(deviceId)
    );
    currentUserId = userId;
    currentDeviceId = deviceId;
  } catch (error) {
    console.error('Failed to create OlmMachine:', error);
    throw error;
  }
}

export function getOlmMachine(): MatrixCrypto.OlmMachine {
  if (!olmMachine) {
    throw new Error('OlmMachine not initialized');
  }
  return olmMachine;
}

export async function generateIdentityKeyPair(): Promise<IdentityKeys> {
  const machine = getOlmMachine();
  const identityKeys = machine.identityKeys;

  return {
    curve25519: {
      key: identityKeys.curve25519.toBase64(),
    },
    ed25519: {
      key: identityKeys.ed25519.toBase64(),
    },
  };
}

export async function generateOneTimeKeys(count: number): Promise<OneTimeKey[]> {
  // Matrix SDK handles one-time key generation internally
  // We return placeholder keys that should be generated by the Matrix SDK
  const keys: OneTimeKey[] = [];
  for (let i = 0; i < count; i++) {
    keys.push({
      id: `otk_${i}_${Date.now()}`,
      key: btoa(crypto.getRandomValues(new Uint8Array(32)).join(',')),
    });
  }
  return keys;
}

export async function markKeysAsPublished(): Promise<void> {
  // Matrix SDK handles this internally during key upload
  // This is a placeholder for compatibility
}

export async function updateTrackedUsers(userIds: string[]): Promise<void> {
  // Matrix SDK handles user tracking internally
  // This is called before key queries and session establishment
  console.log('[Matrix] Tracking users:', userIds);
}

export async function getMissingSessions(userId: string): Promise<string[]> {
  const machine = getOlmMachine();
  const matrixUserId = new MatrixCrypto.UserId(userId);
  const missingDevices = await machine.getMissingSessions([matrixUserId]);

  // The returned type is different than expected, need to handle it properly
  console.log('[Matrix] Missing sessions result:', missingDevices);

  // For now, return empty array - Matrix SDK will handle session establishment internally
  return [];
}

export async function createOutboundSessions(
  userId: string,
  deviceId: string,
  identityKey: string,
  oneTimeKey: ClaimedOneTimeKey
): Promise<void> {
  // Matrix SDK handles outbound session creation internally
  // Sessions are created automatically when needed for encryption
  console.log('[Matrix] Creating outbound session for:', { userId, deviceId, identityKey, oneTimeKey });
}

export async function encryptToDeviceMessage(
  userId: string,
  deviceId: string,
  eventType: string,
  content: unknown
): Promise<EncryptedMessage> {
  // Temporary AES-GCM implementation until full Matrix SDK integration
  const message = JSON.stringify({
    type: eventType,
    content: content,
    timestamp: Date.now(),
  });

  const encoder = new TextEncoder();
  const data = encoder.encode(message);

  // Generate a random key for AES-GCM
  const key = await globalThis.crypto.subtle.generateKey(
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt']
  );

  const iv = globalThis.crypto.getRandomValues(new Uint8Array(12));
  const encrypted = await globalThis.crypto.subtle.encrypt(
    { name: 'AES-GCM', iv },
    key,
    data
  );

  // For now, we'll store the key in the message (NOT SECURE - placeholder)
  const exportedKey = await globalThis.crypto.subtle.exportKey('raw', key);
  const combined = {
    key: btoa(String.fromCharCode(...new Uint8Array(exportedKey))),
    iv: btoa(String.fromCharCode(...iv)),
    data: btoa(String.fromCharCode(...new Uint8Array(encrypted))),
  };

  return {
    type: MessageType.Message,
    body: JSON.stringify(combined),
    sessionId: `${currentUserId}:${currentDeviceId}-${userId}:${deviceId}`,
  };
}

export async function decryptToDeviceMessage(
  senderId: string,
  senderDeviceId: string,
  encryptedMessage: EncryptedMessage
): Promise<PlaintextMessage> {
  try {
    const combined = JSON.parse(encryptedMessage.body);

    // Reconstruct the key and IV
    const keyBytes = new Uint8Array(atob(combined.key).split('').map(char => char.charCodeAt(0)));
    const iv = new Uint8Array(atob(combined.iv).split('').map(char => char.charCodeAt(0)));
    const encryptedData = new Uint8Array(atob(combined.data).split('').map(char => char.charCodeAt(0)));

    // Import the key
    const key = await globalThis.crypto.subtle.importKey(
      'raw',
      keyBytes,
      { name: 'AES-GCM' },
      false,
      ['decrypt']
    );

    // Decrypt the data
    const decrypted = await globalThis.crypto.subtle.decrypt(
      { name: 'AES-GCM', iv },
      key,
      encryptedData
    );

    const decryptedText = new TextDecoder().decode(decrypted);
    const message = JSON.parse(decryptedText);

    return {
      content: typeof message.content === 'string' ? message.content : JSON.stringify(message.content),
      timestamp: message.timestamp || Date.now(),
      messageId: crypto.randomUUID(),
    };
  } catch (error) {
    console.error('Failed to decrypt message:', error);
    throw new Error('Decryption failed');
  }
}

export async function encryptMessage(
  session: Session,
  message: PlaintextMessage
): Promise<EncryptedMessage> {
  return encryptToDeviceMessage(session.remoteUserId, session.remoteDeviceId, 'm.room.message', {
    content: message.content,
    timestamp: message.timestamp,
    messageId: message.messageId,
  });
}

export async function decryptMessage(
  session: Session,
  encryptedMessage: EncryptedMessage
): Promise<PlaintextMessage> {
  return decryptToDeviceMessage(session.remoteUserId, session.remoteDeviceId, encryptedMessage);
}

export async function createOutboundSession(
  _localIdentityKeys: IdentityKeys,
  remotePreKeyBundle: PreKeyBundle
): Promise<Session> {
  if (!currentDeviceId || !currentUserId) {
    throw new Error('Device not initialized');
  }

  const sessionId = `${currentUserId}:${currentDeviceId}-${remotePreKeyBundle.userId}:${remotePreKeyBundle.deviceId}`;

  return {
    sessionId,
    remoteUserId: remotePreKeyBundle.userId,
    remoteDeviceId: remotePreKeyBundle.deviceId,
    state: {
      rootKey: '',
      chainKey: '',
      nextHeaderKey: '',
      headerKey: '',
      messageKeys: {},
      sendingChain: { chainKey: '', messageNumber: 0 },
      receivingChains: [],
      previousCounter: 0,
    },
  };
}

export async function generateSignedPreKey(_ed25519Key: KeyPair): Promise<KeyPair> {
  // Generate a placeholder signed prekey for compatibility
  const privateKey = crypto.getRandomValues(new Uint8Array(32));
  const publicKey = crypto.getRandomValues(new Uint8Array(32));
  const signature = crypto.getRandomValues(new Uint8Array(64));

  return {
    publicKey: {
      key: btoa(String.fromCharCode(...publicKey)),
      signature: btoa(String.fromCharCode(...signature)),
    },
    privateKey: btoa(String.fromCharCode(...privateKey)),
  };
}

export async function generateOneTimePreKeys(count: number): Promise<KeyPair[]> {
  const oneTimeKeys = await generateOneTimeKeys(count);
  return oneTimeKeys.map((key) => ({
    publicKey: {
      key: key.key,
    },
    privateKey: '',
  }));
}
